#include "plugin.hpp"
#include "Chord2Components.h"
#include "pool.h"
#include "utils.h"

ParamId switchParamMap[] = // can't guarantee order of params in ParamId enum when autogenerated
{
    N0_PARAM,
    N1_PARAM,
    N2_PARAM,
    N3_PARAM,
    N4_PARAM,
    N5_PARAM,
    N6_PARAM,
    N7_PARAM,
    N8_PARAM,
    N9_PARAM,
    N10_PARAM,
    N11_PARAM,
    N12_PARAM
};

int maxChans=-1;

struct Channel {
    float amplitude;
    float deltaA;
    int button;
    
    // init and start fade up
    void init(int _button){
        amplitude = 0;
        deltaA = 1.0f; // start fading up
        button = _button;
    }
    
    void update(float rate){
        amplitude = rack::math::clamp(amplitude+deltaA*rate,0.0f,1.0f);
    }
    
    bool finished(){
        return amplitude<=0.0f && deltaA<0.0f;
    }        
    
    void fadeDown(){
        deltaA = -1.0f;
    }
    void fadeUp(){
        deltaA = 1.0f;
    }
};

Channel *buttonChannels[13]; // each note button may be being played be a channel

struct Chord2 : Module {
    dsp::ClockDivider divider;
    dsp::ClockDivider lightdivider;
    
    Pool<Channel> *pool;
    
    bool prevButtonStates[13];
    
    Chord2() {
        pool = NULL; // can't allocate pool until we have maxchans
        
        // CAREFUL - we're using the same IDs for lights as params
        config(PARAMS_LEN, INPUTS_LEN, OUTPUTS_LEN,
               PARAMS_LEN-2 // some params are lights
               );
        
        for(int i=0;i<=12;i++){
            configSwitch(switchParamMap[i], 0.0f, 1.0f, 0.0f,
                         string::f("%d semitones above root",i));
            buttonChannels[i]=NULL;
            prevButtonStates[i]=false;
        }
        configParam(RATE_PARAM, 0.0f, 1.0f, 0.5f, "rate of amp. change");
        configParam(CHANS_PARAM, 0.0f, 12.0f, 4.0f, "channel count");
        configInput(ROOT_INPUT, "Mono 1V/CV input");
        configOutput(POLY_OUTPUT, "Poly 1V/oct output");
        configOutput(CVOUT_OUTPUT, "Poly amplitude CV output");
        
        divider.setDivision(16);
    }
    
    void process(const ProcessArgs& args) override {
        
        int maxc = (int)(params[CHANS_PARAM].getValue()+0.2f);
        if(maxc != maxChans){ // this will also be true when pool=null, at initialisaiton
            maxChans = maxc;
            // switch to new pool
            delete pool;
            pool = new Pool<Channel>(maxc);
            // turn off lights and buttons
            for(int i=0;i<=12;i++){
                params[switchParamMap[i]].setValue(0);
                lights[switchParamMap[i]].setBrightness(0);
                buttonChannels[i]=NULL;
            }
                
        }
        
        // Find edges in button presses
        for(int i=0;i<=12;i++){
            bool st = params[switchParamMap[i]].getValue() >= 0.1f;
            if(st && !prevButtonStates[i]){
                // button went down. 
                // is this button already running in a channel?
                if(buttonChannels[i]){
                    // yes, just fade up
                    buttonChannels[i]->fadeUp();
                } else {
                    // no, allocate a channel and fade up.
                    // If not possible, force the button back up again.
                    Channel *c = pool->alloc();
                    if(!c){
                        params[switchParamMap[i]].setValue(0);
                    } else {
                        c->init(i);
                        buttonChannels[i]=c;
                    }
                }
            } else if (!st && prevButtonStates[i]){
                // button went up. Start the channel fading down.
                if(buttonChannels[i])
                    buttonChannels[i]->fadeDown();
            }
            prevButtonStates[i] = st;
        }
        
        int root = (int)((inputs[ROOT_INPUT].getVoltage()*12.0f)+0.001f);
        float rate = params[RATE_PARAM].getValue() * 0.01f;
        rate *= rate;
        
        // iterate over the running channels, updating them. If a channel has faded down to less than zero,
        // free it. We iterate over ALL channels, not just the running ones, so we
        // can ensure the output channels in the data have consistent numbers, the 
        // channel count is always the same, and non-running channels are zeroed.
        // If we try to swap channels or change the count, we get clicks.
        
        for(int i=0;i<maxChans;i++){
            float amp = 0;
            float pitch = 0;
            
            Channel *c = pool->get(i);
            if(c){
                c->update(rate);
                amp = c->amplitude;
                lights[switchParamMap[c->button]].setBrightness(amp);
                if(c->finished()){
                    pitch = 0;
                    buttonChannels[c->button] = NULL;
                    pool->free(c);
                } else {
                    pitch = ((float)(root+c->button))/12.0f;
                }
            } else {
                amp = 0;
                pitch = 0;
            }
            outputs[CVOUT_OUTPUT].setVoltage(amp*10.0f,i);
            outputs[POLY_OUTPUT].setVoltage(pitch,i);
        }
        outputs[CVOUT_OUTPUT].setChannels(maxChans);
        outputs[POLY_OUTPUT].setChannels(maxChans);
        
    }
};


struct Chord2Widget : ModuleWidget {
    
#define BUTTONSTYLE VCVLightBezelLatch<>
#define RATEKNOBSTYLE RoundBlackKnob
#define CHANKNOBSTYLE Trimpot
    
    Chord2Widget(Chord2* module) {
        setModule(module);
        setPanel(createPanel(asset::plugin(pluginInstance, "res/Chord2.svg")));
        addChild(createWidget<ScrewSilver>(Vec(RACK_GRID_WIDTH, 0)));
        addChild(createWidget<ScrewSilver>(Vec(box.size.x - 2 * RACK_GRID_WIDTH, 0)));
        addChild(createWidget<ScrewSilver>(Vec(RACK_GRID_WIDTH, RACK_GRID_HEIGHT - RACK_GRID_WIDTH)));
        addChild(createWidget<ScrewSilver>(Vec(box.size.x - 2 * RACK_GRID_WIDTH, RACK_GRID_HEIGHT - RACK_GRID_WIDTH)));
        
        
        addParam(createLightParamCentered<BUTTONSTYLE>(mm2px(N0_PARAM_POS), module, N0_PARAM, N0_PARAM));
        addParam(createLightParamCentered<BUTTONSTYLE>(mm2px(N1_PARAM_POS), module, N1_PARAM, N1_PARAM));
        addParam(createLightParamCentered<BUTTONSTYLE>(mm2px(N2_PARAM_POS), module, N2_PARAM, N2_PARAM));
        addParam(createLightParamCentered<BUTTONSTYLE>(mm2px(N3_PARAM_POS), module, N3_PARAM, N3_PARAM));
        addParam(createLightParamCentered<BUTTONSTYLE>(mm2px(N4_PARAM_POS), module, N4_PARAM, N4_PARAM));
        addParam(createLightParamCentered<BUTTONSTYLE>(mm2px(N5_PARAM_POS), module, N5_PARAM, N5_PARAM));
        addParam(createLightParamCentered<BUTTONSTYLE>(mm2px(N6_PARAM_POS), module, N6_PARAM, N6_PARAM));
        addParam(createLightParamCentered<BUTTONSTYLE>(mm2px(N7_PARAM_POS), module, N7_PARAM, N7_PARAM));
        addParam(createLightParamCentered<BUTTONSTYLE>(mm2px(N8_PARAM_POS), module, N8_PARAM, N8_PARAM));
        addParam(createLightParamCentered<BUTTONSTYLE>(mm2px(N9_PARAM_POS), module, N9_PARAM, N9_PARAM));
        addParam(createLightParamCentered<BUTTONSTYLE>(mm2px(N10_PARAM_POS), module, N10_PARAM, N10_PARAM));
        addParam(createLightParamCentered<BUTTONSTYLE>(mm2px(N11_PARAM_POS), module, N11_PARAM, N11_PARAM));
        addParam(createLightParamCentered<BUTTONSTYLE>(mm2px(N12_PARAM_POS), module, N12_PARAM, N12_PARAM));
        
        addParam(createParamCentered<RATEKNOBSTYLE>(mm2px(RATE_PARAM_POS), module, RATE_PARAM));
        addParam(snap(module,createParamCentered<CHANKNOBSTYLE>(mm2px(CHANS_PARAM_POS), module, CHANS_PARAM)));
        
        addInput(createInputCentered<PJ301MPort>(mm2px(ROOT_INPUT_POS), module, ROOT_INPUT));
        addOutput(createOutputCentered<PJ301MPort>(mm2px(POLY_OUTPUT_POS), module, POLY_OUTPUT));
        addOutput(createOutputCentered<PJ301MPort>(mm2px(CVOUT_OUTPUT_POS), module, CVOUT_OUTPUT));
    }
};


Model* modelChord2 = createModel<Chord2, Chord2Widget>("Lliw2");